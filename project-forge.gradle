import net.minecraftforge.forge.tasks.CheckATs
import net.minecraftforge.forge.tasks.CheckExcs
import net.minecraftforge.forge.tasks.CheckPatches
import net.minecraftforge.forge.tasks.CheckSAS
import net.minecraftforge.forge.tasks.ConfigureInstallerJar
import net.minecraftforge.forge.tasks.Crowdin
import net.minecraftforge.forge.tasks.DownloadLibraries
import net.minecraftforge.forge.tasks.FieldCompareFinder
import net.minecraftforge.forge.tasks.InstallerJar
import net.minecraftforge.forge.tasks.InstallerJson
import net.minecraftforge.forge.tasks.LauncherJson
import net.minecraftforge.forge.tasks.Util
import net.minecraftforge.gradle.common.tasks.ApplyRangeMap
import net.minecraftforge.gradle.common.tasks.ExtractExistingFiles
import net.minecraftforge.gradle.common.tasks.ExtractInheritance
import net.minecraftforge.gradle.common.tasks.ExtractRangeMap
import net.minecraftforge.gradle.common.tasks.JarExec
import net.minecraftforge.gradle.mcp.tasks.GenerateSRG
import net.minecraftforge.gradle.patcher.tasks.GenerateBinPatches
import org.apache.tools.ant.filters.ReplaceTokens
import org.gradle.plugins.ide.eclipse.model.SourceFolder

import java.nio.file.Files
import java.util.stream.Collectors

import static net.minecraftforge.forge.tasks.Util.getClasspath

plugins {
    id 'fmlforge.shared-conventions'
    id 'org.cadixdev.licenser'
}

sourceSets {
    main {
        java {
            srcDirs = [
                "$rootDir/src/main/java",
                "$rootDir/src/fmlcommon/java"
            ]
        }
        resources {
            srcDirs = [
                "$rootDir/src/main/resources",
                "$rootDir/src/generated/resources",
                "$rootDir/src/fmlcommon/resources"
            ]
        }
    }
    test {
        java {
            srcDirs = [
                "$rootDir/src/test/java"
            ]
        }
        resources {
            srcDirs = [
                "$rootDir/src/test/resources",
                "$rootDir/src/generated_test/resources"
            ]
        }
    }
}
//Eclipse adds the sourcesets twice, once where we tell it to, once in the projects folder. No idea why. So delete them
eclipse.classpath.file.whenMerged { cls -> cls.entries.removeIf { e -> e instanceof SourceFolder && e.path.startsWith('src/') && !e.path.startsWith('src/main/') } }

ext {
    SPEC_VERSION = gradleutils.gitInfo.tag
    // The new versioning sceme is <MCVersion>-<ForgeMC>.<RB>.<CommitsSinceRB>
    // ForgeMC is a unique identifier for every MC version we have supported.
    // Essentially, the same as the old, except dropping the first number, and the builds are no longer unique.
    MCP_ARTIFACT = project.provider { project(':mcp') }.flatMap { it.mcp.config }
    PACKED_DEPS = [':fmlcore:jar', ':fmlloader:jar', ':javafmllanguage:jar', ':mclanguage:jar']
    MAVEN_PATH = "${group.replace('.', '/')}/${project.name}/${rootProject.VERSION}"
}

configurations {
    versionJson {
        canBeResolved = true
    }
}

dependencies {
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.7.0'
    testImplementation 'org.junit.vintage:junit-vintage-engine:5.+'
    testImplementation 'org.opentest4j:opentest4j:1.2.0' // needed for junit 5
    testImplementation 'org.hamcrest:hamcrest-all:1.3' // needs advanced matching for list order

    versionJson project(path: ':mcp', configuration: 'versionJson')
}

patcher {
    excs.from file("$rootDir/src/main/resources/forge.exc")
    parent = project(':clean')
    patches = file("$rootDir/patches/minecraft")
    patchedSrc = file('src/main/java')
    srgPatches = true
    accessTransformers.from file("$rootDir/src/main/resources/META-INF/accesstransformer.cfg")
    sideAnnotationStrippers.from file("$rootDir/src/main/resources/forge.sas")

    runs {
        forge_client {
            property 'eventbus.checkTypesOnDispatch', 'true'
            args '--launchTarget', 'forgeclientdev'
            ideaModule "${rootProject.name}.${project.name}.main"
            mods {
                minecraft { source sourceSets.main }
            }
        }

        forge_test_client {
            parent runs.forge_client
            taskName 'forge_test_client'

            property 'forge.enableGameTest', 'true'
            environment 'MOD_CLASSES', 'dummy' // Needed to work around FG limitation, FG will replace this!

            ideaModule "${rootProject.name}.${project.name}.test"

            mods {
                tests { sources sourceSets.test }
            }
        }

        forge_server {
            args '--launchTarget', 'forgeserverdev'
            ideaModule "${rootProject.name}.${project.name}.main"

            mods {
                minecraft { source sourceSets.main }
            }
        }

        forge_test_server {
            parent runs.forge_server
            taskName 'forge_test_server'

            property 'forge.enableGameTest', 'true'
            environment 'MOD_CLASSES', 'dummy' // Needed to work around FG limitation, FG will replace this!

            ideaModule "${rootProject.name}.${project.name}.test"

            mods {
                tests { sources sourceSets.test }
            }
        }

        forge_gameTestServer {
            taskName 'forge_gameTestServer'
            args '--launchTarget', 'forgegametestserverdev'
            ideaModule "${rootProject.name}.${project.name}.main"

            mods {
                minecraft { source sourceSets.main }
            }
        }

        forge_test_gameTestServer {
            parent runs.forge_gameTestServer
            taskName 'forge_test_gameTestServer'

            ideaModule "${rootProject.name}.${project.name}.test"

            mods {
                tests { sources sourceSets.test }
            }
        }

        def forgeDataArgs = [
                '--mod', 'forge',
                '--all',
                '--output', rootProject.file('src/generated/resources/'),
                '--validate',
                '--existing', sourceSets.main.resources.srcDirs[0]
                ]
        forge_data {
            taskName 'forge_data'
            args '--launchTarget', 'forgedatadev'
            ideaModule "${rootProject.name}.${project.name}.main"

            mods {
                minecraft { source sourceSets.main }
            }

            args forgeDataArgs
        }

        forge_test_data {
            parent runs.forge_data
            taskName 'forge_test_data'

            environment 'MOD_CLASSES', 'dummy' // Needed to work around FG limitation, FG will replace this!

            ideaModule "${rootProject.name}.${project.name}.test"

            mods {
                tests { sources sourceSets.test }
            }

            afterEvaluate {
                // Clear forge's main datagen args
                args.removeAll {
                    forgeDataArgs.contains(it instanceof File ? (it as File).absolutePath : it.toString())
                }

                args '--flat', '--all', '--validate',
                        '--mod', 'data_gen_test',
                        '--mod', 'piston_event_test',
                        '--mod', 'global_loot_test',
                        '--mod', 'scaffolding_test',
                        '--mod', 'custom_tag_types_test',
                        '--mod', 'new_model_loader_test',
                        '--mod', 'remove_tag_datagen_test',
                        '--mod', 'tag_based_tool_types',
                        '--output', rootProject.file('src/generated_test/resources/'),
                        '--existing', sourceSets.main.resources.srcDirs[0],
                        '--existing', sourceSets.test.resources.srcDirs[0]
            }
        }
    }
}

ext {
    MANIFESTS = [
        '/': [
            'Timestamp': new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
            'GitCommit': gradleutils.gitInfo.abbreviatedId,
            'Git-Branch': gradleutils.gitInfo.branch,
            'FML-System-Mods': 'forge'
        ] as LinkedHashMap,
        'net/minecraftforge/versions/forge/': [
            'Specification-Title':      'Forge',
            'Specification-Vendor':     'Forge Development LLC',
            'Specification-Version':    SPEC_VERSION,
            'Implementation-Title':     project.group,
            'Implementation-Version':   project.version.substring(rootProject.MC_VERSION.length() + 1),
            'Implementation-Vendor':    'Forge Development LLC'
        ] as LinkedHashMap,
        'net/minecraftforge/versions/mcp/': [
            'Specification-Title':      'Minecraft',
            'Specification-Vendor':     'Mojang',
            'Specification-Version':    rootProject.MC_VERSION,
            'Implementation-Title':     'MCP',
            'Implementation-Version':   rootProject.MCP_VERSION,
            'Implementation-Vendor':    'Forge'
        ] as LinkedHashMap,
        'net/minecraftforge/fml/javafmlmod/': [
            'Specification-Title':      'Mod Language Provider',
            'Specification-Vendor':     'Forge Development LLC',
            'Specification-Version':    '1',
            'Implementation-Title':     'FML Java Mod',
            'Implementation-Version':   SPEC_VERSION,
            'Implementation-Vendor':    'Forge'
        ] as LinkedHashMap,
        'net/minecraftforge/fml/mclanguageprovider/': [
            'Specification-Title':      'Mod Language Provider',
            'Specification-Vendor':     'Forge Development LLC',
            'Specification-Version':    '1',
            'Implementation-Title':     'Minecraft Language Mod Provider',
            'Implementation-Version':   '1',
            'Implementation-Vendor':    'Forge'
        ] as LinkedHashMap,
        'net/minecraftforge/fml/loading/': [
            'Specification-Title':      'Launcher',
            'Specification-Vendor':     'Forge Development LLC',
            'Specification-Version':    '1',
            'Implementation-Title':     'FML Launcher',
            'Implementation-Version':   SPEC_VERSION,
            'Implementation-Vendor':    'Forge'
        ] as LinkedHashMap
    ]
}

tasks.register('crowdin', Crowdin) {
    key = project.hasProperty('crowdinKey') ? project.crowdinKey : null
    //TODO: Merge our english.json?
}

rootProject.sharedFmlonlyForge.call(project)

var downloadLibraries = tasks.register('downloadLibraries', DownloadLibraries) {
    dependsOn ':mcp:setupMCP' // TODO: check?
    input = configurations.versionJson.elements.map { it[0].asFile }
    output = rootProject.file('build/libraries/')
}

var extractInheritance = tasks.register('extractInheritance', ExtractInheritance) {
    tool = rootProject.INSTALLER_TOOLS + ':fatjar'
    input = tasks.named('genJoinedBinPatches', GenerateBinPatches).flatMap { it.cleanJar }
    libraries.addAll downloadLibraries.flatMap { it.librariesOutput }.map { rf -> Files.readAllLines(rf.asFile.toPath()).stream().map(File::new).collect(Collectors.toList()) }
}

var findFieldInstanceChecks = tasks.register('findFieldInstanceChecks', FieldCompareFinder) {
    it.jar = tasks.named('createJoinedSRG').flatMap { it.output }
    output = rootProject.file('src/main/resources/coremods/field_to_instanceof.json')
    fields {
        /* 1.17 changed most things to use Tags. So this isn't nessasary anymore so just make an empty list
        bows {
            cls = 'net/minecraft/world/item/Items'
            name = 'f_42411_'
            replacement = 'net/minecraft/world/item/BowItem'
        }
        crossbows {
            cls = 'net/minecraft/world/item/Items'
            name = 'f_42717_'
            replacement = 'net/minecraft/world/item/CrossbowItem'
        }
        */
    }
}

var checkATs = tasks.register('checkATs', CheckATs) {
    inheritance = extractInheritance.flatMap { it.output }
    ats.from patcher.accessTransformers
    mappings = tasks.named('createSrg2Mcp', GenerateSRG).flatMap { it.output }
}

var checkSAS = tasks.register('checkSAS', CheckSAS) {
    inheritance = extractInheritance.flatMap { it.output }
    sass.from patcher.sideAnnotationStrippers
}

var checkExcs = tasks.register('checkExcs', CheckExcs) {
    binary = tasks.named('jar', Jar).flatMap { it.archiveFile }
    excs.from patcher.excs
}

tasks.register('checkAll', Task) {
    dependsOn checkATs, checkSAS, checkExcs, findFieldInstanceChecks
}

tasks.register('checkPatchesAndFix', CheckPatches) {
    dependsOn 'genPatches'
    patchDir = file("$rootDir/patches")
    autoFix = true
}

var checkPatches = tasks.register('checkPatches', CheckPatches) {
    dependsOn 'genPatches'
    patchDir = file("$rootDir/patches")
    autoFix = false
}

tasks.named('genPatches').configure {
    finalizedBy checkPatches
    autoHeader true
    lineEnding = '\n'
}

var launcherJson = tasks.register('launcherJson', LauncherJson) {
    packedConfiguration = configurations.packedLauncherJson
    doFirst {
        def forge_client = project(':forge').patcher.runs.forge_client
        json = [
            _comment_: comment,
            id: id,
            time: timestamp,
            releaseTime: timestamp,
            type: 'release',
            mainClass: 'cpw.mods.bootstraplauncher.BootstrapLauncher',
            inheritsFrom: rootProject.MC_VERSION,
            logging: {},
            arguments: [
                game: ['--launchTarget', 'forgeclient',
                       '--fml.forgeVersion', rootProject.FORGE_VERSION,
                       '--fml.mcVersion', rootProject.MC_VERSION,
                       '--fml.forgeGroup', project.group,
                       '--fml.mcpVersion', rootProject.MCP_VERSION],
                jvm: ["-DignoreList=${forge_client.properties.ignoreList},\${version_name}.jar",
                      "-DmergeModules=${forge_client.properties.mergeModules}",
                      '-DlibraryDirectory=${library_directory}',
                      '-p', Util.getArtifacts(project, configurations.moduleonly, false).values().collect{'${library_directory}/' + it.downloads.artifact.path}.join('${classpath_separator}'),
                      '--add-modules', 'ALL-MODULE-PATH',
                      // Additions to these JVM module args should be mirrored to server_files/args.txt and other similar blocks in the buildscript
                      '--add-opens', 'java.base/java.util.jar=cpw.mods.securejarhandler',
                      '--add-exports', 'java.base/sun.security.util=cpw.mods.securejarhandler',
                      '--add-exports', 'jdk.naming.dns/com.sun.jndi.dns=java.naming'
                ]
            ],
            libraries: []
        ]
    }
}

var installerJson = tasks.register('installerJson', InstallerJson) {
    dependsOn launcherJson, 'genClientBinPatches', 'applyClientBinPatches', 'applyServerBinPatches', 'signUniversalJar'
    ext {
        // remove :fatjar
        BIN_PATCHER = rootProject.BINPATCH_TOOL.substring(0, rootProject.BINPATCH_TOOL.length() - 1 - rootProject.BINPATCH_TOOL.split(':')[3].length())
    }
    input.from tasks.named('genClientBinPatches').flatMap { it.toolJar }, launcherJson.flatMap { it.output }
    icon = rootProject.file('icon.ico')
    packedConfiguration = configurations.packedInstallerJson

    ['client', 'server'].each { side ->
        ['slim', 'extra'].each { type ->
            input.from tasks.named("download${side.capitalize()}${type.capitalize()}").flatMap { it.output }
        }
        input.from tasks.named("create${side.capitalize()}SRG").flatMap { it.output }
        input.from tasks.named("apply${side.capitalize()}BinPatches").flatMap { it.output }
    }
    input.from tasks.named('universalJar', Zip).flatMap { it.archiveFile }

    doFirst {
        def libs = libraries

        var universalJarTask = tasks.named('universalJar', Zip).get()
        addLibrary(libs, Util.getMavenDep(universalJarTask), Util.getMavenPath(universalJarTask), universalJarTask.archiveFile.get().asFile)

        net.minecraftforge.gradle.common.util.Artifact mcpArtifact = MCP_ARTIFACT.get()
        json = [
            _comment_: launcherJson.get().comment,
            spec: 1,
            profile: project.name,
            version: launcherJson.get().id,
            path: null,
            minecraft: rootProject.MC_VERSION,
            serverJarPath: '{LIBRARY_DIR}/net/minecraft/server/{MINECRAFT_VERSION}/server-{MINECRAFT_VERSION}.jar',
            data: [
                MAPPINGS: [
                    client: "[${mcpArtifact.group}:${mcpArtifact.name}:${mcpArtifact.version}:mappings@txt]",
                    server: "[${mcpArtifact.group}:${mcpArtifact.name}:${mcpArtifact.version}:mappings@txt]"
                ],
                MOJMAPS: [
                    client: "[net.minecraft:client:${rootProject.MC_VERSION}-${rootProject.MCP_VERSION}:mappings@txt]",
                    server: "[net.minecraft:server:${rootProject.MC_VERSION}-${rootProject.MCP_VERSION}:mappings@txt]"
                ],
                MERGED_MAPPINGS: [
                    client: "[${mcpArtifact.group}:${mcpArtifact.name}:${mcpArtifact.version}:mappings-merged@txt]",
                    server: "[${mcpArtifact.group}:${mcpArtifact.name}:${mcpArtifact.version}:mappings-merged@txt]"
                ],
                BINPATCH: [
                    client: '/data/client.lzma',
                    server: '/data/server.lzma'
                ],
                MC_UNPACKED: [
                    client: "[net.minecraft:client:${rootProject.MC_VERSION}-${rootProject.MCP_VERSION}:unpacked]",
                    server: "[net.minecraft:server:${rootProject.MC_VERSION}-${rootProject.MCP_VERSION}:unpacked]"
                ],
                MC_SLIM: [
                    client: "[net.minecraft:client:${rootProject.MC_VERSION}-${rootProject.MCP_VERSION}:slim]",
                    server: "[net.minecraft:server:${rootProject.MC_VERSION}-${rootProject.MCP_VERSION}:slim]"
                ],
                MC_SLIM_SHA: [
                    client: "'${downloadClientSlim.output.get().asFile.sha1()}'",
                    server: "'${downloadServerSlim.output.get().asFile.sha1()}'"
                ],
                MC_EXTRA: [
                    client: "[net.minecraft:client:${rootProject.MC_VERSION}-${rootProject.MCP_VERSION}:extra]",
                    server: "[net.minecraft:server:${rootProject.MC_VERSION}-${rootProject.MCP_VERSION}:extra]"
                ],
                MC_EXTRA_SHA: [
                    client: "'${downloadClientExtra.output.get().asFile.sha1()}'",
                    server: "'${downloadServerExtra.output.get().asFile.sha1()}'"
                ],
                MC_SRG: [
                    client: "[net.minecraft:client:${rootProject.MC_VERSION}-${rootProject.MCP_VERSION}:srg]",
                    server: "[net.minecraft:server:${rootProject.MC_VERSION}-${rootProject.MCP_VERSION}:srg]"
                ],
                /*MC_SRG_SHA: [
                    client: "'${createClientSRG.output.sha1()}'",
                    server: "'${createServerSRG.output.sha1()}'"
                ],*/
                PATCHED: [
                    client: "[${project.group}:${project.name}:${project.version}:client]",
                    server: "[${project.group}:${project.name}:${project.version}:server]"
                ],
                PATCHED_SHA: [
                    client: "'${applyClientBinPatches.output.get().asFile.sha1()}'",
                    server: "'${applyServerBinPatches.output.get().asFile.sha1()}'"
                ],
                MCP_VERSION: [
                    client: "'${rootProject.MCP_VERSION}'",
                    server: "'${rootProject.MCP_VERSION}'"
                ]
            ],
            processors: [
                [
                    sides: ['server'],
                    jar: rootProject.INSTALLER_TOOLS,
                    classpath: getClasspath(project, libs, rootProject.INSTALLER_TOOLS),
                    args: [
                        '--task', 'EXTRACT_FILES',
                        '--archive', '{INSTALLER}',

                        '--from', 'data/run.sh',
                        '--to',   '{ROOT}/run.sh',
                        '--exec', '{ROOT}/run.sh',
                        //'--from', "data/run_forge_${rootProject.VERSION.replace('-', '_').sh",
                        //'--to',   '{ROOT}/run_forge_${rootProject.VERSION.replace('-', '_').sh',
                        //'--exec', '{ROOT}/run_forge_${rootProject.VERSION.replace('-', '_').sh',

                        '--from', 'data/run.bat',
                        '--to',   '{ROOT}/run.bat',
                        //'--from', 'data/run_forge_${rootProject.VERSION.replace('-', '_').bat',
                        //'--to',   '{ROOT}/run_forge_${rootProject.VERSION.replace('-', '_').bat',

                        '--from',     'data/user_jvm_args.txt',
                        '--to',       '{ROOT}/user_jvm_args.txt',
                        '--optional', '{ROOT}/user_jvm_args.txt',

                        '--from', 'data/win_args.txt',
                        '--to',   "{ROOT}/libraries/${MAVEN_PATH}/win_args.txt",

                        '--from', 'data/unix_args.txt',
                        '--to',   "{ROOT}/libraries/${MAVEN_PATH}/unix_args.txt"
                    ]
                ], [
                    sides: ['server'],
                    jar: rootProject.INSTALLER_TOOLS,
                    classpath: getClasspath(project, libs, rootProject.INSTALLER_TOOLS),
                    args: [
                        '--task', 'BUNDLER_EXTRACT',
                        '--input', '{MINECRAFT_JAR}',
                        '--output', '{ROOT}/libraries/',
                        '--libraries'
                    ]
                ], [
                    sides: ['server'],
                    jar: rootProject.INSTALLER_TOOLS,
                    classpath: getClasspath(project, libs, rootProject.INSTALLER_TOOLS),
                    args: [
                        '--task', 'BUNDLER_EXTRACT',
                        '--input', '{MINECRAFT_JAR}',
                        '--output', '{MC_UNPACKED}',
                        '--jar-only'
                    ]
                ], [
                    jar: rootProject.INSTALLER_TOOLS,
                    classpath: getClasspath(project, libs, rootProject.INSTALLER_TOOLS),
                    args: [
                        '--task', 'MCP_DATA',
                        '--input', "[${mcpArtifact.descriptor}]",
                        '--output', '{MAPPINGS}',
                        '--key', 'mappings'
                    ]
                ], [
                    jar: rootProject.INSTALLER_TOOLS,
                    classpath: getClasspath(project, libs, rootProject.INSTALLER_TOOLS),
                    args: [
                        '--task', 'DOWNLOAD_MOJMAPS',
                        '--version', rootProject.MC_VERSION,
                        '--side', '{SIDE}',
                        '--output', '{MOJMAPS}'
                    ]
                ], [
                    jar: rootProject.INSTALLER_TOOLS,
                    classpath: getClasspath(project, libs, rootProject.INSTALLER_TOOLS),
                    args: [
                        '--task', 'MERGE_MAPPING',
                        '--left', '{MAPPINGS}',
                        '--right', '{MOJMAPS}',
                        '--output', '{MERGED_MAPPINGS}',
                        '--classes', '--reverse-right'
                    ]
                ], [
                    sides: ['client'],
                    jar: rootProject.JAR_SPLITTER,
                    classpath: getClasspath(project, libs, rootProject.JAR_SPLITTER),
                    args: [
                        '--input', '{MINECRAFT_JAR}',
                        '--slim',  '{MC_SLIM}',
                        '--extra', '{MC_EXTRA}',
                        '--srg', '{MERGED_MAPPINGS}'
                    ],
                    outputs: [
                        '{MC_SLIM}': '{MC_SLIM_SHA}',
                        '{MC_EXTRA}': '{MC_EXTRA_SHA}'
                    ]
                ], [
                    sides: ['server'],
                    jar: rootProject.JAR_SPLITTER,
                    classpath: getClasspath(project, libs, rootProject.JAR_SPLITTER),
                    args: [
                        '--input', '{MC_UNPACKED}',
                        '--slim',  '{MC_SLIM}',
                        '--extra', '{MC_EXTRA}',
                        '--srg', '{MERGED_MAPPINGS}'
                    ],
                    outputs: [
                        '{MC_SLIM}': '{MC_SLIM_SHA}',
                        '{MC_EXTRA}': '{MC_EXTRA_SHA}'
                    ]
                ], [
                    jar: rootProject.FART,
                    classpath: getClasspath(project, libs, rootProject.FART),
                    args: [
                        '--input', '{MC_SLIM}',
                        '--output', '{MC_SRG}',
                        '--names', '{MERGED_MAPPINGS}',
                        '--ann-fix', '--ids-fix', '--src-fix', '--record-fix'
                    ]/*,
                    outputs: [
                        '{MC_SRG}': '{MC_SRG_SHA}'
                    ]
                    */
                ], [
                    jar: BIN_PATCHER,
                    classpath: getClasspath(project, libs, BIN_PATCHER),
                    args: [
                        '--clean', '{MC_SRG}',
                        '--output', '{PATCHED}',
                        '--apply', '{BINPATCH}'
                    ]/*, Because Vignette is unstable, it screws with the entry order of the binpatched jar, so we can't use the hash right now
                    // Re-enable this when https://github.com/CadixDev/Vignette/issues/1 is solved
                    outputs: [
                        '{PATCHED}': '{PATCHED_SHA}'
                    ]*/
                ]
            ]
        ]
        getClasspath(project, libs, mcpArtifact.descriptor) //Tell it to download mcp_config
    }
}

tasks.named('universalJar').configure {
    from rootProject.extraTxts

    // add crowdin locales
    from { crowdin.output.present && crowdin.output.get().asFile.exists() ? zipTree(crowdin.output) : null}
    dependsOn crowdin
    duplicatesStrategy = 'exclude'

    doFirst {
        MANIFESTS.each{ pkg, values ->
            if (pkg == '/') {
                manifest.attributes(values)
            } else {
                manifest.attributes(values, pkg)
            }
        }
    }
}

var configureInstallerJar = tasks.register('configureInstallerJar', ConfigureInstallerJar)
var installerJar = tasks.register('installerJar', InstallerJar) {
    dependsOn configureInstallerJar, 'genClientBinPatches', 'genServerBinPatches', 'signUniversalJar'
    from(rootProject.extraTxts)
    from(rootProject.file('/forge_installer_logo.png')) {
        rename { 'big_logo.png' }
    }
    from(genClientBinPatches.output) {
        rename { 'data/client.lzma' }
    }
    from(genServerBinPatches.output) {
        rename { 'data/server.lzma' }
    }

    def downloadInstaller = tasks.named('downloadInstaller')

    dependsOn installerJson, launcherJson, downloadInstaller
    from installerJson.flatMap { it.output }, launcherJson.flatMap { it.output }

    from(project.zipTree(downloadInstaller.flatMap { it.output })) {
        duplicatesStrategy = 'exclude'
    }
}

configureInstallerJar.configure {
    targetTask = installerJar
    addPackedDependencies = !System.env.MAVEN_USER
    packedConfiguration = configurations.packedInstallerJar
}

var makeMdk = tasks.register('makeMdk', Zip) {
    archiveBaseName = project.name
    archiveClassifier = 'mdk'
    archiveVersion = project.version
    destinationDirectory = file('build/libs')

    from rootProject.file('gradlew')
    from rootProject.file('gradlew.bat')
    from rootProject.extraTxts
    from(rootProject.file('gradle/')){
        into('gradle/')
    }
    from(rootProject.file('mdk/')){
        rootProject.file('mdk/gitignore.txt').eachLine{
            if (!it.trim().isEmpty() && !it.trim().startsWith('#'))
                exclude it
        }
        filter(ReplaceTokens, tokens: [
            FORGE_VERSION: project.version,
            FORGE_GROUP: project.group,
            FORGE_NAME: project.name,
            MC_VERSION: rootProject.MC_VERSION,
            MAPPING_CHANNEL: rootProject.MAPPING_CHANNEL,
            MAPPING_VERSION: rootProject.MAPPING_VERSION,
            FORGE_SPEC_VERSION: SPEC_VERSION.split("\\.")[0],
            MC_NEXT_VERSION: "1."+((rootProject.MC_VERSION.split("[\\.-]")[1] as int)+1)
        ])
        rename 'gitignore\\.txt', '.gitignore'
        rename 'gitattributes\\.txt', '.gitattributes'
    }
}

license {
    header = file("$rootDir/LICENSE-header.txt")

    ext {
        year = new Date().format("yyyy")
    }

    include 'net/minecraftforge/'
    exclude 'net/minecraftforge/server/terminalconsole/'
    exclude 'net/minecraftforge/api/' // exclude API here because it's validated in the SPI build
    exclude 'net/minecraftforge/fml/common/versioning/ComparableVersion.java'
    exclude 'net/minecraftforge/fml/common/versioning/InvalidVersionSpecificationException.java'
    exclude 'net/minecraftforge/fml/common/versioning/Restriction.java'
    exclude 'net/minecraftforge/fml/common/versioning/VersionRange.java'
    exclude 'net/minecraftforge/common/LenientUnboundedMapCodec.java'

    tasks {
        main {
            files.from files("$rootDir/src/main/java")
        }
        test {
            files.from files("$rootDir/src/test/java")
        }
    }
}

tasks.named('reobfJar', JarExec) {
    tool = rootProject.FART
    args = ['--input', '{input}', '--output', '{output}', '--map', '{srg}']
}

tasks.named('eclipse').configure {
    dependsOn('genEclipseRuns')
}

if (project.hasProperty('UPDATE_MAPPINGS')) {
    tasks.named('extractRangeMap', ExtractRangeMap).configure {
        sources.from sourceSets.test.java.srcDirs
        addDependencies sourceSets.test.compileClasspath
    }
    tasks.named('applyRangeMap', ApplyRangeMap).configure {
        sources.from sourceSets.test.java.srcDirs
    }
    tasks.named('extractMappedNew', ExtractExistingFiles).configure {
        targets.from sourceSets.test.java.srcDirs
    }
}

publishing {
    publications {
        mavenJava(MavenPublication) {
            artifact tasks.named('universalJar')
            artifact installerJar
            //TODO: installer-win
            artifact makeMdk
            artifact tasks.named('userdevJar')
            artifact tasks.named('sourcesJar')
        }
    }
}
// Since we need the modules in the bootstrap, we need to make sure they are compiled before we do each run
afterEvaluate { tasks.named('prepareRuns').configure { dependsOn(':fmlcore:jar', ':fmlloader:jar', ':javafmllanguage:jar', ':mclanguage:jar') } }

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8' // Use the UTF-8 charset for Java compilation
}
